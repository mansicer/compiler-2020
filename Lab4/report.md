# 编译原理第四次实验报告

## 文件结构

- Code：包含所有代码文件。其中`lexical.l`，`syntax.y`，`main.c`为原有文件，进行了相关实现；`config.h`包含实验中的部分类型和宏定义；`treenode.h`和`treenode.c`为实验需要定义的多叉树数据结构；`symtable.h`和`symtable.c`是实验所用到的符号表实现；`semantic.h`和`semantic.c`包含了语义分析的相关函数；`immediate.h`和`immediate.c`包含了中间代码生成的相关函数；`machine.h`和`machine.c`包含机器代码生成的相关函数；`Makefile`为得到二进制文件的原有代码，未进行修改。
- Test：测试用例目录。
- parser：使用make命令得到的可执行文件。
- README：原有文件，未修改。
- report.pdf：本报告文件。



## 实验内容

### 机器代码结构

在产生中间代码时，我们使用了一个双向链表容器来暂时存储中间代码，方便我们后续进行修改，而由于中间代码与机器代码之间有很好的对应关系，我们在生成机器代码时根据中间代码进行生成，其过程可以无需暂时保存到一个容器中，而是直接输出到对应的输出文件里。鉴于这样的特性，为了不增加数据结构的复杂性，我们没有为机器代码定义结构，而是通过一些辅助函数直接将字符串形式的机器代码输出到文本文件中。



### 操作数的存储

每个中间代码中得到使用的操作数，都需要映射到机器代码中一定的物理空间中，这个物理空间可以是寄存器，也可以是内存，实际计算时，某个操作数也可能同时存放在寄存器和内存中，为此我们设计了一个数据结构`VarPos`，描述一个中间代码中的操作数对应的存放位置，其被初始化为`P_NOWHERE`，表示还没有为该操作数选择存放的位置。由此我们定义数组

```
VarPos var_range[NUM_OF_OPERANDS];
```

其中`NUM_OF_OPERANDS`为中间代码操作数的总数目，即可反映所有操作数对应的存储位置。



### 指令选择

由于我们的中间代码是线性的，一般上都可以直接映射到机器代码，我们可以遍历之前存储的中间代码容器，对中间代码进行逐条翻译，即可得到对应的机器代码。对于大多数中间代码而言，其都用一条或几条指令直接对应到机器代码，但也有某些中间代码类型到机器代码的转换稍显复杂，我们会在后文简单描述我们是怎么完成的。

在指令选择与翻译时，我们设计了两个常用的辅助函数`operand_to_reg`和`reg_to_operand`，前者将一个操作数从其所在的存储空间移动到一个指定的寄存器中，后者将一个寄存器中的值移动到一个操作数的存储空间，如果该操作数还没有分配存储空间，就为其分配一个存储空间。

设计了这两个函数后，对于大多数的算术运算指令，其翻译模式就变得很简单：先将参与运算的操作数全部移动到某些寄存器，然后在这些寄存器上进行计算，最后将计算的结果赋值到对应操作数的存储空间。而这里的存储空间具体在内存还是寄存器即可根据我们的寄存器分配算法而定。

对于一些特殊指令，我们需要进行其他的处理：

#### `ARG`指令

将对应的操作数存入`arg_list`中。

#### `CALL`指令

#### `CALL`指令

1. 保存原来的`$a0-a3`寄存器的值。
2. 将`arg_list`中的参数压栈。
3. 将`$ra`的值压栈，跳转到函数，执行完成后，将`$ra`的值出栈。
4. 将原来压入的参数出栈，并恢复此前`$ai`的值。
5. 将存储在`$v0`中的返回值赋值给对应的操作数。

#### `PARAM`指令

假设当前为第`i`个参数，如果是前 4 个，就令对应操作数的存储位置为`$ai`寄存器，否则为`$fp + 8 + 4 * (i - 4)`的地址位置。



### 栈分配

我们在生成机器代码时使用了`$30`寄存器作为栈帧指针`$fp`，因此我们必须为每个函数维护好该寄存器的值，在运行新的函数时保存原来的栈帧，并在`return`时恢复原有的栈帧。

由于这样的原因，我们需要特殊处理这样的一些指令：

#### `FUNCTION`指令

1. 将当前的`$fp`入栈。
2. 将`$fp`赋值为当前的`$sp`。

#### `RETURN`指令

1. 将返回值存储到`$v0`寄存器。
2. 将`$sp`赋值为当前的`$fp`。
3. 将`$fp`赋值为内存地址`0($fp)`对应的值，即原来的`$fp`值。
4. 将原来的`$fp`值出栈。



### 寄存器分配

我们采用朴素的寄存器方法来分配寄存器，即在一般情况下，除了参数以外的所有操作数，在第一次使用时我们都会为其在内存的栈区分配一个位置。为了能够得知一个新的操作数应当分配到内存的哪里，我们设置了一个当前偏移`cur_offset`变量，并修改了中间代码生成，在中间代码的每个函数结束时增加一个`END_OF_FUNCTION`标记，来达成我们的需求。

