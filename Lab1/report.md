# 编译原理第一次实验报告

## 文件结构

- Code：包含所有代码文件。其中`lexical.l`，`syntax.y`，`main.c`为原有文件，进行了相关实现；`treenode.h`和`treenode.c`为实验需要定义的多叉树数据结构；`Makefile`为得到二进制文件的原有代码，未进行修改。
- Test：测试用例，其中case1-6.cmm对应实验讲义中的6个用例（4个必做样例和2个选做1选做样例），test1-2.cmm对应原有文件，未修改。
- parser：使用make命令得到的可执行文件。
- README：原有文件，未修改。
- report.pdf：本报告文件。



## 实验内容

### 词法分析部分

使用实验讲义附录A的词法定义对C--编译器中的各个词法单元进行定义，另外完成了选做内容，对八进制和十六进制整数的输入进行识别。下面列出采用的词法单元定义。

```
INT         0|([1-9][0-9]*)
OCTONARY    0[0-7]+
HEXADECIMAL 0[xX][0-9A-Fa-f]+
```

如果使用该定义，我们需要确保在规则阶段，八进制整数的词法单元`OCTONARY`与十六进制的词法单元`HEXADECIMAL`在`INT`之前处理，否则八进制与十六进制首位的0会被显示别为`INT`，从而产生错误。我们也可以将八进制整数的词法单元定义为`0[0-7]*`，使得单个的0直接被识别为八进制整数，这对整数值没有影响。我们没有在词法阶段识别不正确输入的八进制或十六进制整数，这样的错误可以在语法阶段得到识别。如09可以被识别为`INT` `INT`从而引发语法错误，0xG可以被识别为`INT` `ID`从而引发错误。



### 语法分析部分

使用实验讲义附录A的语法定义对C--编译器的各个非终结符产生式进行定义，并且根据附录中的优先级表为各个终结符设定对应的优先级和结合关系，其中减号/负号`MINUS`终结符按照减号的优先级进行处理，因为减号的优先级低且为左结合，不会影响到对负号的规约。我们也可以考虑为减号和负号设置不同的终结符，这需要从词法阶段入手，但由于二者的定义都是`-`符号，就为词法识别上的区分带来了困难，考虑到减号和负号之后的语法单元都为`Exp`，我们只能通过其前的语法单元做判断，通过计算可以发现减号前的终结符可以是`LP, LB, ID, INT, FLOAT`，而负号前的终结符也可以是`LP`，这就为我们在词法阶段识别减号和负号造成进一步的困难，我们可能需要往前看2个甚至更多个词素才能知道如何识别减号和负号。考虑到不在词法阶段区分减号和负号没有对编译器的运行造成过分的问题，我们采取了将减号和负号都看作非终结符`MINUS`的方法。

此外，根据实验讲义中的描述，我们通过bison的`nonassoc`方法使得语法分析器识别嵌套`if-else`语句块的过程更为严谨。我们人为修改`yyerror`函数使其不输出任何信息，并自定义了`cmmerror`函数使得我们能够在标准错误流输出我们所希望报错的信息。

最后，我们描述一下编译器的错误恢复部分，这也是最有难度的地方。尽管我做了很多的尝试，也没有办法满足让编译器检查出所有错误，考虑到添加过多的错误相关产生式会使得`bison`在编译时产生许多的冲突，因此我们只能尽量在必要的地方添加错误恢复的产生式，如`Stmt`语句，`CompSt`语句，`Exp`语句，`Def`语句等等。经过测试，我还发现在一些参数列表的文法单元中，如`VarList`，`Args`添加一些错误恢复的产生式能够让C--编译器识别出更多的语法错误。



### 语法树的构造

在实验1中，我们需要为语法分析的结果构造一棵语法树，并在语法分析没有出现错误时将语法树输出，语法树的本质是一棵多叉树，这需要我们实现一定的数据结构来进行存储和维护，这样的代码结构被我们实现在了`treenode.h`和`treenode.c`文件里。考虑到我们使用的文法产生式并不长，在代码中我们限制了每个节点的最大子节点数为10，足够满足我们的语法树需求。每个树节点结构里除了必要的索引属性外，还包括了`name`，`info`，`lineno`三个属性，分别用于表示文法符号的名称、存储的内容信息以及出现的行号。我们实现了`createTreeNode`函数用于分配一个给定信息的节点，两个函数`insertChild`和`insertChildren`用于为一个节点插入一个或多个子节点，函数`printTree`用于打印语法树信息，以及函数`destroyTree`用于在完成打印后释放多叉树占用的内存空间。

由于我们将每个文法单元作为了多叉树的节点，因此我们就将其类型均设置为我们的多叉树节点`TreeNode *`，使得我们可以直接调用上述的函数建立起多叉树。我们先设置`%union`使其包含`TreeNode *node`，对非终结符号的类型设置通过`bison`中的`%type`命令进行，对终结符还需在`flex`源文件里在处理过程中通过设置`yylval`创建起终结符的多叉树节点。

