# 编译原理第三次实验报告

## 文件结构

- Code：包含所有代码文件。其中`lexical.l`，`syntax.y`，`main.c`为原有文件，进行了相关实现；`config.h`包含实验中的部分类型和宏定义；`treenode.h`和`treenode.c`为实验需要定义的多叉树数据结构；`symtable.h`和`symtable.c`是实验所用到的符号表实现；`semantic.h`和`semantic.c`包含了语义分析的相关函数；`immediate.h`和`immediate.c`包含了中间代码生成的相关函数；`Makefile`为得到二进制文件的原有代码，未进行修改。
- Test：测试用例目录。
- parser：使用make命令得到的可执行文件。
- README：原有文件，未修改。
- report.pdf：本报告文件。



## 实验内容

### 操作数

我们实现了操作数结构`Operand`，并在实验中定义了三种类型的操作数：变量`O_VARIABLE`（对应在原`cmm`代码中有出现的变量），临时变量`O_TEMP`（生成中间代码时需要使用到的变量）以及常量`O_CONSTANT`（以`#`开头的常数）。除了常量以外的操作数，可以存在左值`O_LEFTVAL`（即取地址，对应`&`操作符）和右值`O_RIGHTVAL`（取该地址的值，对应`*`操作符）以及取该变量的值`O_VAL`三种类别。我们实现了函数`translate_Operand`将操作数类型翻译为可以写入中间代码的字符串。



### 中间代码结构

我们实现了中间代码结构`InterCode`，根据讲义中的虚拟机指令设计了不同种类的中间代码形式。由于我们在实验中并非是在分析语法树的同时将中间代码直接写入文件，而是存入一个临时的容器中，因此我们设计了一个容器`icodelist`用于存放已生成的中间代码。实验刚开始时我使用了单向链表来进行实现，随着实验的深入，发现在优化中间代码时往往会涉及到对现有中间代码的删除操作，使用单向链表便显得不够方便，因此我们改用了双向链表作为中间代码的存储容器。

在中间代码全部生成后，我们通过`print_intercode`函数一次性将所有中间代码输出到指定的输出文件指针中，该函数能够根据中间代码数据结构的内容，将其翻译成对应的可供虚拟机读取的字符串。

同时我们也修改了`main.c`的主函数，使其接收参数中还需要提供输出文件路径。





### 中间代码生成

为了生成中间代码，根据讲义说明，我们需要在语义分析步骤前将用于中间代码生成的`read`和`write`函数以给定的形式加入到符号表中，该部分代码通过`prepare_ir`函数实现，我们在语义分析前调用该函数。

完成语义分析后，如果没有产生错误，我们就可以进行中间代码生成了。中间代码生成的过程可以沿用先前的语法树来遍历，但遍历的过程相较于语义分析没有那么繁琐，这体现在我们可以不用考虑变量的声明和定义（在选做部分中我们还是需要考虑数组的定义的，我们会在在后面描述这部分内容），以及其他一些不会产生具体行为的语句，因此我们需要注意的往往是对`Stmt`以及其会产生的语法结构的中间代码生成。但是在变量定义时，事实上我们需要**确定一个该变量在中间代码生成时的名称**（在我们的实验中是一个如`v1`，`v2`这样的符号），为此我们需要在符号表中为变量的符号新增一项`var_no`，指代其在中间代码中的符号，该过程被添加到我们的中间代码生成过程中（也可以添加到语义分析过程中），即**每发现一个被定义的变量，我们都在符号表中为其添加一个指代其在中间代码生成时使用的符号**。

在代码实现中，我们参考讲义中的指导，以函数`translate_X`表示对语法单元`X`的的翻译过程。除此之外，函数`translate_Cond`被用于翻译`Exp`产生的布尔条件变量。大多函数均为`translate_X(p)`的格式，其中`p`为语法树的对应节点，而`translate_Exp(p, temp_no)`除了要求提供对应的语法树节点，还提供了临时变量`temp_no`，我们需要将当前`Exp`生成后的值存放到临时变量`temp_no`中。也正因如此，很多`Exp`相关的操作的结果，如四则运算等各类运算指令，在不需要`temp_no`的情况下，其往往是没有语义的，我们可以考虑下面这个语句

```c
int x, y;
x + y;
```

其中第二行的加法运算的结果没有得到记录，因此实际生成中间代码时是可以不需要生成这个加法指令的。



### 选做内容

选做内容要求我们在代码中允许多维数组的变量，以及一维数组的函数参数，实际编程时我们没有区分这两个操作（即都按照允许多维数组完成）。为了实现这样的功能，首先我们需要实现在数组定义时生成中间代码，为对应的变量生成中间代码的`DEC`指令，生成足够的数组空间，数组空间的大小取决于该类型，由于符号表中已经有该类型的变量记录，因此我们只需要查找符号表中的该变量类型信息，就能计算出其应分配的空间大小，并生成对应中间代码。

接下来我们考虑数组访问的操作，我们实现了一个`a = translate_array(p, temp_no)`函数，用于产生式`Exp -> Exp LB Exp RB`以及`Exp -> Exp ASSIGNOP Exp`当需要赋值的`Exp`为数组元素时的情况。其中`p`为对应的`Exp`语法树节点，`temp_no`存放经过函数计算后，该数组元素基于基址上的偏移量，而返回值`a`存放数组基址所在的变量名。

1. 当存在产生式`Exp -> Exp LB Exp RB`需要数组访问时，我们调用`translate_array`函数获取访问的基址和偏移量，并将二者相加存放在`t1`临时变量，然后根据该`Exp`需要的返回值`t`，生成中间代码`t := *t1`即可。
2. 当存在产生式`Exp0 -> Exp1 ASSIGNOP Exp2`，且赋值号左侧的`Exp1`为数组元素时，我们调用`translate_array(Exp1, t1)`获取基址和偏移量，将二者相加存放在`t1`中，同时我们还需调用`translate_Exp(Exp2, t2)`，将需要赋值的值存放在`t2`中，最后生成中间代码`*t1 = t2`即可。

由于虚拟机的指令要求，我们还需要注意数组变量的表达方式。当我们执行中间代码`DEC v1 20`时，得到的`v1`是一个数组变量，其实际基址应当在`&v1`中（这与C语言的表达有着一些差异），而当我们将该数组作为参数传给一个函数时，我们应当传递的值是该数组的基址`&v1`。但是这样一来，如果我们访问一个数组`v2`，且`v2`是当前函数的参数时，那么其基址就应该表达为`v2`而非`&v2`，这样**前后二者的基址表达就产生了歧义**。和C语言比较，C语言的数组变量本身的值是一个表示基址的指针，就不会拥有这样的歧义。为了解决这样的问题，实际上我们需要做的是将函数参数以及函数中定义的变量进行区分，容易想到这样的区分可以在语义分析时完成。为此我们在符号表中为变量的符号添加了一项`is_param`来表示其是否为函数参数，如果是，则我们在获取该数组变量时直接使用其自身的值表示，否则我们添加`&`对该变量取基址。



### 中间代码优化

中间代码优化的过程在完成了所有中间代码产生后开始，被定义在`optimize_intercode`函数中。中间代码的优化是一个复杂的过程，我们只尝试对一些简单的情形进行优化。在我们的实验代码中，我们考虑了三种情形：

1. 如果我们发现存在临时变量的赋值`t1 := x`（其中`x`是另一个操作数），且在中间代码中没有其他语句也对`t1`赋值过，那么我们可以将中间代码中所有的`t1`替换为`x`，从而减掉对`t1`这个临时变量的使用。

2. 如果我们发现存在以下的模式

   ```
   IF a > b GOTO l1
   GOTO l2
   LABEL l1 :
   ...
   LABEL l2 :
   ```

   如果标记`l1`在此以外的其他位置都没有得到使用，那么我们可以对原有的逻辑判断式`a > b`进行改造，将其取反得到`a <= b`（对其他逻辑关系符也能对应地取反），从而得到下面的式子

   ```
   IF a <= b GOTO l2
   ...
   LABEL l2 :
   ```

   我们可以从中减少2行中间代码。

3. 如果我们发现存在以下的模式

   ```
   GOTO l1 :
   LABEL l1 :
   ```

   如果标记`l1`在除此以外的其他位置都没有得到使用，那么我们可以直接删除这两行代码，因为这两行代码是不必要的。

采取了以上三个优化方法后，我们使用董杨静同学提供的`compilers-test`模块（https://github.com/massimodong/compilers-tests，感谢董同学贡献的测试框架，也感谢所有提供测试用例的同学）进行测试，选取了其中不包含选修3-1（即代码中没有结构体）的绝大多测试用例，**未优化下生成的中间代码在虚拟机上总共执行了257901条指令**，而**优化后的中间代码仅执行了133255条指令**，在确保运行正确的同时，**几乎减少了一半左右的指令执行数目**。

